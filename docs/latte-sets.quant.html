<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-sets.quant documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-sets</span> <span class="project-version">1.0b10-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte-sets</span></div></div></li><li class="depth-2 branch"><a href="latte-sets.algebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>algebra</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.equiv.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>equiv</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.pfun.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pfun</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerrel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerrel</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerset</span></div></a></li><li class="depth-2 branch current"><a href="latte-sets.quant.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quant</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.ralgebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ralgebra</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.rel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rel</span></div></a></li><li class="depth-2"><a href="latte-sets.set.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-sets.quant.html#var-decompose-exists-in-type"><div class="inner"><span>decompose-exists-in-type</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-decompose-forall-in-type"><div class="inner"><span>decompose-forall-in-type</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-decompose-single-in-type"><div class="inner"><span>decompose-single-in-type</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-ex-in-elim"><div class="inner"><span>ex-in-elim</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-ex-in-elim-rule"><div class="inner"><span>ex-in-elim-rule</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-ex-in-intro"><div class="inner"><span>ex-in-intro</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-exists-in"><div class="inner"><span>exists-in</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-forall-in"><div class="inner"><span>forall-in</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-single-in"><div class="inner"><span>single-in</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-single-in-elim"><div class="inner"><span>single-in-elim</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-single-in-elim-rule"><div class="inner"><span>single-in-elim-rule</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-single-in-intro"><div class="inner"><span>single-in-intro</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-the-element"><div class="inner"><span>the-element</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-the-element-ax"><div class="inner"><span>the-element-ax</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-the-element-lemma"><div class="inner"><span>the-element-lemma</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-the-element-lemma-prop"><div class="inner"><span>the-element-lemma-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-the-element-prop"><div class="inner"><span>the-element-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-the-element-prop-ax"><div class="inner"><span>the-element-prop-ax</span></div></a></li><li class="depth-1"><a href="latte-sets.quant.html#var-unique-in"><div class="inner"><span>unique-in</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-sets.quant</h1><div class="doc"><div class="markdown"><p>Quantifiers over sets (rather than types), with most definitions specialized from <a href="null">latte-prelude.quant</a>.</p></div></div><div class="public anchor" id="var-decompose-exists-in-type"><h3>decompose-exists-in-type</h3><div class="usage"><code>(decompose-exists-in-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-decompose-forall-in-type"><h3>decompose-forall-in-type</h3><div class="usage"><code>(decompose-forall-in-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-decompose-single-in-type"><h3>decompose-single-in-type</h3><div class="usage"><code>(decompose-single-in-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-ex-in-elim"><h3>ex-in-elim</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>The elimination rule for the <code>exists-in</code> existential quantifier over a set <code>s</code> (of elements of type <code>T</code>). A typical proof instance is of the form <code>(ex-in-elim ex-proof A-proof)</code> with <code>ex-term</code> a proof of <code>(exists-in [x s] (P x))</code> and <code>A-proof</code> a proof of <code>(==&gt; (forall-in [x s] (==&gt; (P x) A)))</code>. See <a href="null">ex-in-elem-rule</a>.</p></div></div></div><div class="public anchor" id="var-ex-in-elim-rule"><h3>ex-in-elim-rule</h3><div class="usage"><code>(ex-in-elim-rule [s (set T)] [P (==&gt; T :type)] [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (exists-in [x s] (P x)) (forall-in [y s] (==&gt; (P y) A)) A)
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for <code>exists-in</code> existentials, a set-theoretic variant of <a href="null">latte-prelude.quant/ex-elim-rule</a>.</p></div></div></div><div class="public anchor" id="var-ex-in-intro"><h3>ex-in-intro</h3><div class="usage"><code>(ex-in-intro [s (set T)] [P (==&gt; T :type)] [x T])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (elem x s) (P x) (exists-in [y s] (P y)))
</code></pre>
<p><strong>Theorem</strong>: The introduction rule for the <code>exists-in</code> quantifier, cf. <a href="null">latte-prelude.quant/ex-intro-thm</a>.</p></div></div></div><div class="public anchor" id="var-exists-in"><h3>exists-in</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Existential quantification over sets.</p>
<p><code>(exists-in [x s] (P x))</code> is a shortcut for <code>(exists [x (element-type-of s)]
                 (and (elem x s)
                      (P x)))</code>.</p></div></div></div><div class="public anchor" id="var-forall-in"><h3>forall-in</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Universal quantification over sets.</p>
<p><code>(forall-in [x s] (P x))</code> is a shortcut for <code>(forall [x (element-type-of s)]
                 (==&gt; (elem x s)
                      (P x)))</code>.</p></div></div></div><div class="public anchor" id="var-single-in"><h3>single-in</h3><div class="usage"><code>(single-in [s (set T)] [P (==&gt; T :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall-in [x s] (forall-in [y s] (==&gt; (P x) (P y) (equal x y))))
</code></pre>
<p><strong>Definition</strong>: The constraints that “there exists at most one element of type <code>T</code> in set <code>s</code> such that…”</p>
<p>This is a set-theoretic variant of <a href="null">latte-prelude.quant/single</a>.</p></div></div></div><div class="public anchor" id="var-single-in-elim"><h3>single-in-elim</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Elimination rule for <a href="latte-sets.quant.html#var-single-in">single-in</a>. <code>(single-in-elim s-proof x y)</code> such that the type of <code>s-proof</code> is <code>(single-in s P)</code> for some property <code>P</code>, then we have <code>(==&gt; (P x) (P y) (equal x y))</code> thanks to <code>[[single-in-elim-rule]]</code>.</p></div></div></div><div class="public anchor" id="var-single-in-elim-rule"><h3>single-in-elim-rule</h3><div class="usage"><code>(single-in-elim-rule [s (set T)] [P (==&gt; T :type)] [x T] [y T])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (single-in s P) (elem x s) (elem y s) (P x) (P y) (equal x y))
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for <a href="latte-sets.quant.html#var-single-in">single-in</a>.</p></div></div></div><div class="public anchor" id="var-single-in-intro"><h3>single-in-intro</h3><div class="usage"><code>(single-in-intro [s (set T)] [P (==&gt; T :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (forall-in [x s] (forall-in [y s] (==&gt; (P x) (P y) (equal x y))))
 (single-in s P))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for <a href="latte-sets.quant.html#var-single-in">single-in</a>.</p></div></div></div><div class="public anchor" id="var-the-element"><h3>the-element</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>The unique element descriptor for sets.</p>
<p><code>(the-element u)</code> defines the unique element of  set <code>s</code> satisfying the predicate <code>P</code>. This is provided  thanks to the uniqueness proof <code>u</code> (of type <code>(unique-in s P)</code>.</p>
<p>This is the set-theoretic version of the <a href="null">latte-prelude.quant/the</a>.</p></div></div></div><div class="public anchor" id="var-the-element-ax"><h3>the-element-ax</h3><div class="usage"><code>(the-element-ax [T :type] [s (set T)] [P (==&gt; T :type)] [u (unique-in s P)])</code></div><div class="doc"><div class="markdown"><pre><code>T
</code></pre>
<p><strong>Axiom</strong>: The unique element descriptor axiom.</p>
<p>This is a set-theoretic variant of <a href="null">latte-prelude.quant/the-ax</a>.</p></div></div></div><div class="public anchor" id="var-the-element-lemma"><h3>the-element-lemma</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>(the-element-lemma u)</code> proves that <code>(forall-in [y s] (==&gt; (P y) (equal y (the-element u))))</code> from the proof <code>u</code> that <code>(unique-in s P)</code> for some property <code>P</code> and set <code>s</code>.</p></div></div></div><div class="public anchor" id="var-the-element-lemma-prop"><h3>the-element-lemma-prop</h3><div class="usage"><code>(the-element-lemma-prop [s (set T)] [P (==&gt; T :type)] [u (unique-in s P)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall-in [y s] (==&gt; (P y) (equal y (the-element u))))
</code></pre>
<p><strong>Theorem</strong>: The unique element … in <code>s</code> is … unique, cf <a href="null">latte-prelude.quand/the-lemma-thm</a>.</p></div></div></div><div class="public anchor" id="var-the-element-prop"><h3>the-element-prop</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>(the-element-prop u)</code> proves <code>(P (the-element u))</code> from the proof <code>u</code> of <code>(unique-in s P)</code>, for some property <code>P</code> and set <code>s</code>. This is the main property of the unique descriptor <a href="latte-sets.quant.html#var-the-element">the-element</a>, cf <a href="latte-sets.quant.html#var-the-element-prop-ax">the-element-prop-ax</a>.</p></div></div></div><div class="public anchor" id="var-the-element-prop-ax"><h3>the-element-prop-ax</h3><div class="usage"><code>(the-element-prop-ax [T :type] [s (set T)] [P (==&gt; T :type)] [u (unique-in s P)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (elem (the-element u) s) (P (the-element u)))
</code></pre>
<p><strong>Axiom</strong>: The property of the unique element descriptor, cf. <a href="null">latte-prelude.quant/the-prop-ax</a>.</p></div></div></div><div class="public anchor" id="var-unique-in"><h3>unique-in</h3><div class="usage"><code>(unique-in [s (set T)] [P (==&gt; T :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (exists-in [x s] (P x)) (single-in s P))
</code></pre>
<p><strong>Definition</strong>: The constraint that “there exists a unique element of type <code>T</code>  in set <code>s</code> such that …”.</p>
<p>This is a set-theoretic variant of <a href="null">latte-prelude.quant/unique-prop</a>.</p></div></div></div></div></body></html>