<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-sets.rel documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-sets</span> <span class="project-version">1.0b10-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte-sets</span></div></div></li><li class="depth-2 branch"><a href="latte-sets.algebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>algebra</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.equiv.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>equiv</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.pfun.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pfun</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerrel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerrel</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerset</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.quant.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quant</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.ralgebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ralgebra</span></div></a></li><li class="depth-2 branch current"><a href="latte-sets.rel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rel</span></div></a></li><li class="depth-2"><a href="latte-sets.set.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-sets.rel.html#var-dom"><div class="inner"><span>dom</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-emptyrel"><div class="inner"><span>emptyrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-emptyrel-prop"><div class="inner"><span>emptyrel-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-fetch-rel-type"><div class="inner"><span>fetch-rel-type</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-fullrel"><div class="inner"><span>fullrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-fullrel-prop"><div class="inner"><span>fullrel-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-functional"><div class="inner"><span>functional</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-funrel"><div class="inner"><span>funrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-funrel-functional"><div class="inner"><span>funrel-functional</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ident-refl"><div class="inner"><span>ident-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ident-sym"><div class="inner"><span>ident-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ident-trans"><div class="inner"><span>ident-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-identity"><div class="inner"><span>identity</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-prod"><div class="inner"><span>prod</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel"><div class="inner"><span>psubrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-antirefl"><div class="inner"><span>psubrel-antirefl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-antisym"><div class="inner"><span>psubrel-antisym</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-emptyrel"><div class="inner"><span>psubrel-emptyrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-emptyrel-conv"><div class="inner"><span>psubrel-emptyrel-conv</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-emptyrel-equiv"><div class="inner"><span>psubrel-emptyrel-equiv</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-psubrel-trans"><div class="inner"><span>psubrel-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ran"><div class="inner"><span>ran</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rcomp"><div class="inner"><span>rcomp</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rcomp-assoc"><div class="inner"><span>rcomp-assoc</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rcomp-assoc-subrel"><div class="inner"><span>rcomp-assoc-subrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rcomp-assoc-suprel"><div class="inner"><span>rcomp-assoc-suprel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-refl-closure"><div class="inner"><span>refl-closure</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-refl-closure-smallest"><div class="inner"><span>refl-closure-smallest</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-refl-closure-sub"><div class="inner"><span>refl-closure-sub</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-reflexive"><div class="inner"><span>reflexive</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-reflexive-refl-closure"><div class="inner"><span>reflexive-refl-closure</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel"><div class="inner"><span>rel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal"><div class="inner"><span>rel-equal</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-implies-releq"><div class="inner"><span>rel-equal-implies-releq</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-implies-subrel"><div class="inner"><span>rel-equal-implies-subrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-prop"><div class="inner"><span>rel-equal-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-refl"><div class="inner"><span>rel-equal-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-releq"><div class="inner"><span>rel-equal-releq</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-sym"><div class="inner"><span>rel-equal-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-trans"><div class="inner"><span>rel-equal-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq"><div class="inner"><span>releq</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-implies-rel-equal"><div class="inner"><span>releq-implies-rel-equal</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-refl"><div class="inner"><span>releq-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-sym"><div class="inner"><span>releq-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-trans"><div class="inner"><span>releq-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-relfun"><div class="inner"><span>relfun</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-relfun-img"><div class="inner"><span>relfun-img</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-relfun-img-prop"><div class="inner"><span>relfun-img-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-relfunrel-equal"><div class="inner"><span>relfunrel-equal</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-relfunrel-ext-equal"><div class="inner"><span>relfunrel-ext-equal</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel"><div class="inner"><span>subrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-emptyrel-lower-bound"><div class="inner"><span>subrel-emptyrel-lower-bound</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-fullrel-upper-bound"><div class="inner"><span>subrel-fullrel-upper-bound</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-prop"><div class="inner"><span>subrel-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-refl"><div class="inner"><span>subrel-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-trans"><div class="inner"><span>subrel-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-symm-closure"><div class="inner"><span>symm-closure</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-symm-closure-smallest"><div class="inner"><span>symm-closure-smallest</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-symm-closure-sub"><div class="inner"><span>symm-closure-sub</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-symmetric"><div class="inner"><span>symmetric</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-symmetric-symm-closure"><div class="inner"><span>symmetric-symm-closure</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-transitive"><div class="inner"><span>transitive</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-sets.rel</h1><div class="doc"><div class="markdown"><p>A <strong>relation</strong> from elements of a given type <code>T</code> to elements of <code>U</code> is formalized with type <code>(==&gt; T U :type)</code>.</p>
<p>This namespace provides some important properties about such  relations.</p></div></div><div class="public anchor" id="var-dom"><h3>dom</h3><div class="usage"><code>(dom [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(set-of [x T] (exists [y U] (R x y)))
</code></pre>
<p><strong>Definition</strong>: The domain of relation <code>R</code>.</p></div></div></div><div class="public anchor" id="var-emptyrel"><h3>emptyrel</h3><div class="usage"><code>(emptyrel [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [y U] p/absurd))
</code></pre>
<p><strong>Definition</strong>: The empty relation.</p></div></div></div><div class="public anchor" id="var-emptyrel-prop"><h3>emptyrel-prop</h3><div class="usage"><code>(emptyrel-prop [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (forall [y U] (not ((emptyrel T U) x y))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-fetch-rel-type"><h3>fetch-rel-type</h3><div class="usage"><code>(fetch-rel-type def-env ctx r-type)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-fullrel"><h3>fullrel</h3><div class="usage"><code>(fullrel [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [y U] p/truth))
</code></pre>
<p><strong>Definition</strong>: The full (total) relation between <code>T</code> and <code>U</code>.</p></div></div></div><div class="public anchor" id="var-fullrel-prop"><h3>fullrel-prop</h3><div class="usage"><code>(fullrel-prop [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (forall [y U] ((fullrel T U) x y)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-functional"><h3>functional</h3><div class="usage"><code>(functional [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (q/unique (lambda [y U] (R x y))))
</code></pre>
<p><strong>Definition</strong>: </p></div></div></div><div class="public anchor" id="var-funrel"><h3>funrel</h3><div class="usage"><code>(funrel [f (==&gt; T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [y U] (equal (f x) y)))
</code></pre>
<p><strong>Definition</strong>: The relation corresponding to function <code>f</code>.</p></div></div></div><div class="public anchor" id="var-funrel-functional"><h3>funrel-functional</h3><div class="usage"><code>(funrel-functional [f (==&gt; T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(functional (funrel f))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-ident-refl"><h3>ident-refl</h3><div class="usage"><code>(ident-refl [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(reflexive (identity T))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-ident-sym"><h3>ident-sym</h3><div class="usage"><code>(ident-sym [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(symmetric (identity T))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-ident-trans"><h3>ident-trans</h3><div class="usage"><code>(ident-trans [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(transitive (identity T))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-identity"><h3>identity</h3><div class="usage"><code>(identity [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x y T] (equal x y))
</code></pre>
<p><strong>Definition</strong>: The indentity relation on <code>T</code>.</p></div></div></div><div class="public anchor" id="var-prod"><h3>prod</h3><div class="usage"><code>(prod [s1 (set T)] [s2 (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [y U] (and (elem x s1) (elem y s2))))
</code></pre>
<p><strong>Definition</strong>: The cartersian product of sets <code>s1</code> and <code>s2</code>, i.e. <code>s1</code>⨯<code>s2</code>.</p></div></div></div><div class="public anchor" id="var-psubrel"><h3>psubrel</h3><div class="usage"><code>(psubrel [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (subrel R1 R2) (not (releq R1 R2)))
</code></pre>
<p><strong>Definition</strong>: The anti-reflexive variant of <a href="latte-sets.rel.html#var-subrel">subrel</a>.</p></div></div></div><div class="public anchor" id="var-psubrel-antirefl"><h3>psubrel-antirefl</h3><div class="usage"><code>(psubrel-antirefl [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(not (psubrel R R))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubrel-antisym"><h3>psubrel-antisym</h3><div class="usage"><code>(psubrel-antisym [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(not (and (psubrel R1 R2) (psubrel R2 R1)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubrel-emptyrel"><h3>psubrel-emptyrel</h3><div class="usage"><code>(psubrel-emptyrel [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (psubrel (emptyrel T U) R) (not (releq R (emptyrel T U))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubrel-emptyrel-conv"><h3>psubrel-emptyrel-conv</h3><div class="usage"><code>(psubrel-emptyrel-conv [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (not (releq R (emptyrel T U))) (psubrel (emptyrel T U) R))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubrel-emptyrel-equiv"><h3>psubrel-emptyrel-equiv</h3><div class="usage"><code>(psubrel-emptyrel-equiv [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (psubrel (emptyrel T U) R) (not (releq R (emptyrel T U))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubrel-trans"><h3>psubrel-trans</h3><div class="usage"><code>(psubrel-trans [R1 (rel T U)] [R2 (rel T U)] [R3 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (psubrel R1 R2) (psubrel R2 R3) (psubrel R1 R3))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-ran"><h3>ran</h3><div class="usage"><code>(ran [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(set-of [y U] (exists [x T] (R x y)))
</code></pre>
<p><strong>Definition</strong>: The range of relation <code>R</code>.</p></div></div></div><div class="public anchor" id="var-rcomp"><h3>rcomp</h3><div class="usage"><code>(rcomp [R1 (rel T U)] [R2 (rel U V)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [z V] (exists [y U] (and (R1 x y) (R2 y z)))))
</code></pre>
<p><strong>Definition</strong>: Sequential relational composition.</p></div></div></div><div class="public anchor" id="var-rcomp-assoc"><h3>rcomp-assoc</h3><div class="usage"><code>(rcomp-assoc [R1 (rel T U)] [R2 (rel U V)] [R3 (rel V W)])</code></div><div class="doc"><div class="markdown"><pre><code>(releq (rcomp R1 (rcomp R2 R3)) (rcomp (rcomp R1 R2) R3))
</code></pre>
<p><strong>Theorem</strong>: Relational composition is associative.</p></div></div></div><div class="public anchor" id="var-rcomp-assoc-subrel"><h3>rcomp-assoc-subrel</h3><div class="usage"><code>(rcomp-assoc-subrel [R1 (rel T U)] [R2 (rel U V)] [R3 (rel V W)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel (rcomp R1 (rcomp R2 R3)) (rcomp (rcomp R1 R2) R3))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rcomp-assoc-suprel"><h3>rcomp-assoc-suprel</h3><div class="usage"><code>(rcomp-assoc-suprel [R1 (rel T U)] [R2 (rel U V)] [R3 (rel V W)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel (rcomp (rcomp R1 R2) R3) (rcomp R1 (rcomp R2 R3)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-refl-closure"><h3>refl-closure</h3><div class="usage"><code>(refl-closure [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x y T] (or (R x y) (equal x y)))
</code></pre>
<p><strong>Definition</strong>: The reflexive closure of relation <code>R</code>.</p></div></div></div><div class="public anchor" id="var-refl-closure-smallest"><h3>refl-closure-smallest</h3><div class="usage"><code>(refl-closure-smallest [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall
 [S (rel T T)]
 (==&gt; (subrel R S) (reflexive S) (subrel (refl-closure R) S)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-refl-closure-sub"><h3>refl-closure-sub</h3><div class="usage"><code>(refl-closure-sub [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel R (refl-closure R))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-reflexive"><h3>reflexive</h3><div class="usage"><code>(reflexive [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (R x x))
</code></pre>
<p><strong>Definition</strong>: A reflexive relation.</p></div></div></div><div class="public anchor" id="var-reflexive-refl-closure"><h3>reflexive-refl-closure</h3><div class="usage"><code>(reflexive-refl-closure [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(reflexive (refl-closure R))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rel"><h3>rel</h3><div class="usage"><code>(rel [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; T U :type)
</code></pre>
<p><strong>Definition</strong>: The type of relations.</p></div></div></div><div class="public anchor" id="var-rel-equal"><h3>rel-equal</h3><div class="usage"><code>(rel-equal [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [P (==&gt; (rel T U) :type)] (&lt;=&gt; (P R1) (P R2)))
</code></pre>
<p><strong>Definition</strong>: A <em>Leibniz</em>-stype equality for relations.</p>
<p>It says that two relations <code>R1</code> and <code>R2</code> are equal iff for any predicate <code>P</code> then <code>(P R1)</code> if and only if <code>(P R2)</code>.</p>
<p>Note that the identification with <a href="latte-sets.set.html#var-seteq">seteq</a> is non-trivial,  and requires an axiom.</p></div></div></div><div class="public anchor" id="var-rel-equal-implies-releq"><h3>rel-equal-implies-releq</h3><div class="usage"><code>(rel-equal-implies-releq [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal R1 R2) (releq R1 R2))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rel-equal-implies-subrel"><h3>rel-equal-implies-subrel</h3><div class="usage"><code>(rel-equal-implies-subrel [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal R1 R2) (subrel R1 R2))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rel-equal-prop"><h3>rel-equal-prop</h3><div class="usage"><code>(rel-equal-prop [R1 (rel T U)] [R2 (rel T U)] [P (==&gt; (rel T U) :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal R1 R2) (P R1) (P R2))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rel-equal-refl"><h3>rel-equal-refl</h3><div class="usage"><code>(rel-equal-refl [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(rel-equal R R)
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rel-equal-releq"><h3>rel-equal-releq</h3><div class="usage"><code>(rel-equal-releq [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (rel-equal R1 R2) (releq R1 R2))
</code></pre>
<p><strong>Theorem</strong>: Coincidence of <em>Leibniz</em>-style and subset-based equality for relations.</p></div></div></div><div class="public anchor" id="var-rel-equal-sym"><h3>rel-equal-sym</h3><div class="usage"><code>(rel-equal-sym [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal R1 R2) (rel-equal R2 R1))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-rel-equal-trans"><h3>rel-equal-trans</h3><div class="usage"><code>(rel-equal-trans [R1 (rel T U)] [R2 (rel T U)] [R3 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal R1 R2) (rel-equal R2 R3) (rel-equal R1 R3))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-releq"><h3>releq</h3><div class="usage"><code>(releq [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (subrel R1 R2) (subrel R2 R1))
</code></pre>
<p><strong>Definition</strong>: Subset-based equality on relations.</p></div></div></div><div class="public anchor" id="var-releq-implies-rel-equal"><h3>releq-implies-rel-equal</h3><div class="usage"><code>(releq-implies-rel-equal [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (releq R1 R2) (rel-equal R1 R2))
</code></pre>
<p><strong>Axiom</strong>: As for the set case (cf. <a href="null">sets/seteq-implies-set-equal</a>), going from the subset-based equality to the (thus more general) <em>leibniz</em>-style one requires an axiom.</p></div></div></div><div class="public anchor" id="var-releq-refl"><h3>releq-refl</h3><div class="usage"><code>(releq-refl [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(releq R R)
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-releq-sym"><h3>releq-sym</h3><div class="usage"><code>(releq-sym [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (releq R1 R2) (releq R2 R1))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-releq-trans"><h3>releq-trans</h3><div class="usage"><code>(releq-trans [R1 (rel T U)] [R2 (rel T U)] [R3 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (releq R1 R2) (releq R2 R3) (releq R1 R3))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-relfun"><h3>relfun</h3><div class="usage"><code>(relfun [R (rel T U)] [fproof (functional R)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (q/the (fproof x)))
</code></pre>
<p><strong>Definition</strong>: The function corresponding to a total, functional relation.</p></div></div></div><div class="public anchor" id="var-relfun-img"><h3>relfun-img</h3><div class="usage"><code>(relfun-img [R (rel T U)] [fproof (functional R)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall
 [x T]
 (forall [y U] (==&gt; (R x y) (equal ((relfun R fproof) x) y))))
</code></pre>
<p><strong>Theorem</strong>: The image of a functional relation</p></div></div></div><div class="public anchor" id="var-relfun-img-prop"><h3>relfun-img-prop</h3><div class="usage"><code>(relfun-img-prop [R (rel T U)] [fproof (functional R)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (R x ((relfun R fproof) x)))
</code></pre>
<p><strong>Theorem</strong>: The property of the relational/functional image.</p></div></div></div><div class="public anchor" id="var-relfunrel-equal"><h3>relfunrel-equal</h3><div class="usage"><code>(relfunrel-equal [f (==&gt; T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(equal f (relfun (funrel f) (funrel-functional f)))
</code></pre>
<p><strong>Theorem</strong>: This is the intentional variant of <a href="latte-sets.rel.html#var-relfunrel-ext-equal">relfunrel-ext-equal</a>.</p></div></div></div><div class="public anchor" id="var-relfunrel-ext-equal"><h3>relfunrel-ext-equal</h3><div class="usage"><code>(relfunrel-ext-equal [f (==&gt; T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall
 [x T]
 (equal (f x) ((relfun (funrel f) (funrel-functional f)) x)))
</code></pre>
<p><strong>Theorem</strong>: This is the extensional equality of a function <code>f</code> and its relational characterization.</p></div></div></div><div class="public anchor" id="var-subrel"><h3>subrel</h3><div class="usage"><code>(subrel [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (forall [y U] (==&gt; (R1 x y) (R2 x y))))
</code></pre>
<p><strong>Definition</strong>: The subset ordering for relations, i.e. <code>R1</code>⊆<code>R2</code></p></div></div></div><div class="public anchor" id="var-subrel-emptyrel-lower-bound"><h3>subrel-emptyrel-lower-bound</h3><div class="usage"><code>(subrel-emptyrel-lower-bound [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel (emptyrel T U) R)
</code></pre>
<p><strong>Theorem</strong>: The empty relation is a subset of every other relations.</p></div></div></div><div class="public anchor" id="var-subrel-fullrel-upper-bound"><h3>subrel-fullrel-upper-bound</h3><div class="usage"><code>(subrel-fullrel-upper-bound [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel R (fullrel T U))
</code></pre>
<p><strong>Theorem</strong>: The full relation is a superset of every other relations.</p></div></div></div><div class="public anchor" id="var-subrel-prop"><h3>subrel-prop</h3><div class="usage"><code>(subrel-prop [P (==&gt; T U :type)] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (forall [x T] (forall [y U] (==&gt; (R2 x y) (P x y))))
 (subrel R1 R2)
 (forall [x T] (forall [y U] (==&gt; (R1 x y) (P x y)))))
</code></pre>
<p><strong>Theorem</strong>: Preservation of properties on relational subsets.</p></div></div></div><div class="public anchor" id="var-subrel-refl"><h3>subrel-refl</h3><div class="usage"><code>(subrel-refl [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel R R)
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-subrel-trans"><h3>subrel-trans</h3><div class="usage"><code>(subrel-trans [R1 (rel T U)] [R2 (rel T U)] [R3 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (subrel R1 R2) (subrel R2 R3) (subrel R1 R3))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-symm-closure"><h3>symm-closure</h3><div class="usage"><code>(symm-closure [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x y T] (or (R x y) (R y x)))
</code></pre>
<p><strong>Definition</strong>: The symmetric closure of relation <code>R</code>.</p></div></div></div><div class="public anchor" id="var-symm-closure-smallest"><h3>symm-closure-smallest</h3><div class="usage"><code>(symm-closure-smallest [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall
 [S (rel T T)]
 (==&gt; (subrel R S) (symmetric S) (subrel (symm-closure R) S)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-symm-closure-sub"><h3>symm-closure-sub</h3><div class="usage"><code>(symm-closure-sub [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel R (symm-closure R))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-symmetric"><h3>symmetric</h3><div class="usage"><code>(symmetric [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x y T] (==&gt; (R x y) (R y x)))
</code></pre>
<p><strong>Definition</strong>: A symmetric relation.</p></div></div></div><div class="public anchor" id="var-symmetric-symm-closure"><h3>symmetric-symm-closure</h3><div class="usage"><code>(symmetric-symm-closure [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(symmetric (symm-closure R))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-transitive"><h3>transitive</h3><div class="usage"><code>(transitive [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x y z T] (==&gt; (R x y) (R y z) (R x z)))
</code></pre>
<p><strong>Definition</strong>: A transitive relation.</p></div></div></div></div></body></html>