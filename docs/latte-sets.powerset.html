<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-sets.powerset documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-sets</span> <span class="project-version">0.5.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte-sets</span></div></div></li><li class="depth-2 branch"><a href="latte-sets.algebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>algebra</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.pfun.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pfun</span></div></a></li><li class="depth-2 branch current"><a href="latte-sets.powerset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerset</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.ralgebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ralgebra</span></div></a></li><li class="depth-2"><a href="latte-sets.rel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rel</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-sets.powerset.html#var-empty-powerset"><div class="inner"><span>empty-powerset</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-empty-powerset-prop"><div class="inner"><span>empty-powerset-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-fetch-powerset-type"><div class="inner"><span>fetch-powerset-type</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-full-powerset"><div class="inner"><span>full-powerset</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-full-powerset-prop"><div class="inner"><span>full-powerset-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-intersections"><div class="inner"><span>intersections</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-intersections-def"><div class="inner"><span>intersections-def</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-intersections-lower-bound"><div class="inner"><span>intersections-lower-bound</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-intersections-prop"><div class="inner"><span>intersections-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-powerset"><div class="inner"><span>powerset</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-powerset1"><div class="inner"><span>powerset1</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-powerset1-prop"><div class="inner"><span>powerset1-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-powerset1-prop-conv"><div class="inner"><span>powerset1-prop-conv</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-powerset1-prop-equiv"><div class="inner"><span>powerset1-prop-equiv</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-set-elem"><div class="inner"><span>set-elem</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-set-elem-def"><div class="inner"><span>set-elem-def</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-set-ex"><div class="inner"><span>set-ex</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-set-ex-def"><div class="inner"><span>set-ex-def</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-set-ex-elim"><div class="inner"><span>set-ex-elim</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-set-ex-elim-thm"><div class="inner"><span>set-ex-elim-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-set-ex-intro"><div class="inner"><span>set-ex-intro</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-set-ex-intro-thm"><div class="inner"><span>set-ex-intro-thm</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-set-single"><div class="inner"><span>set-single</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-set-single-def"><div class="inner"><span>set-single-def</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-set-unique"><div class="inner"><span>set-unique</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-set-unique-def"><div class="inner"><span>set-unique-def</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-the-set"><div class="inner"><span>the-set</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-the-set-ax"><div class="inner"><span>the-set-ax</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-the-set-lemma"><div class="inner"><span>the-set-lemma</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-the-set-prop"><div class="inner"><span>the-set-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-unions"><div class="inner"><span>unions</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-unions-def"><div class="inner"><span>unions-def</span></div></a></li><li class="depth-1"><a href="latte-sets.powerset.html#var-unions-upper-bound"><div class="inner"><span>unions-upper-bound</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-sets.powerset</h1><div class="doc"><div class="markdown"><p>Notions about the powerset construction.</p>
<p>In the predicate-as-set encoding of set-theoretic notions,  the powerset construction (i.e. building a set of sets) is not immediate. The reason is that the set constructor `(set T)’  is not itself a type (but a kind). Hence we need to replicate  some part of the type theory (e.g. the existential quantifier) to deal with powersets.</p></div></div><div class="public anchor" id="var-empty-powerset"><h3>empty-powerset</h3><div class="usage"><code>(empty-powerset [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x (set T)] p/absurd)
</code></pre>
<p><strong>Definition</strong>: The empty powerset.</p></div></div></div><div class="public anchor" id="var-empty-powerset-prop"><h3>empty-powerset-prop</h3><div class="usage"><code>(empty-powerset-prop [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x (set T)] (not (set-elem x (empty-powerset T))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-fetch-powerset-type"><h3>fetch-powerset-type</h3><div class="usage"><code>(fetch-powerset-type def-env ctx s-type)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-full-powerset"><h3>full-powerset</h3><div class="usage"><code>(full-powerset [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x (set T)] p/truth)
</code></pre>
<p><strong>Definition</strong>: The powerset containing all the subsets of type <code>T</code>.</p></div></div></div><div class="public anchor" id="var-full-powerset-prop"><h3>full-powerset-prop</h3><div class="usage"><code>(full-powerset-prop [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x (set T)] (set-elem x (full-powerset T)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-intersections"><h3>intersections</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(intersections X)</code></p>
<p>Generalize intersections. This is the set {y:T | ∀x∈X, y∈x}.</p></div></div></div><div class="public anchor" id="var-intersections-def"><h3>intersections-def</h3><div class="usage"><code>(intersections-def [T :type] [X (powerset T)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [y T] (forall [x (set T)] (==&gt; (set-elem x X) (elem y x))))
</code></pre>
<p><strong>Definition</strong>: Generalize intersections. This is the set {y:T | ∀x∈X, y∈x}.</p></div></div></div><div class="public anchor" id="var-intersections-lower-bound"><h3>intersections-lower-bound</h3><div class="usage"><code>(intersections-lower-bound [T :type] [X (powerset T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x (set T)] (==&gt; (set-elem x X) (subset (intersections X) x)))
</code></pre>
<p><strong>Theorem</strong>: The generalized intersection is a lower bound wrt. the subset relation.</p></div></div></div><div class="public anchor" id="var-intersections-prop"><h3>intersections-prop</h3><div class="usage"><code>(intersections-prop [T :type] [P (==&gt; T :type)] [X (powerset T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall
 [x (set T)]
 (==&gt;
  (set-elem x X)
  (forall [y T] (==&gt; (elem y x) (P y)))
  (forall [z T] (==&gt; (elem z (intersections X)) (P z)))))
</code></pre>
<p><strong>Theorem</strong>: Preservation of properties on intersections.</p></div></div></div><div class="public anchor" id="var-powerset"><h3>powerset</h3><div class="usage"><code>(powerset [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set T) :type)
</code></pre>
<p><strong>Definition</strong>: The powerset constructor.</p>
<p>The term <code>(powerset T)' is the type
of sets whose elements are sets of type</code>T`.</p></div></div></div><div class="public anchor" id="var-powerset1"><h3>powerset1</h3><div class="usage"><code>(powerset1 [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x (set T)] (not (s/set-equal x (s/emptyset T))))
</code></pre>
<p><strong>Definition</strong>: The powerset of all the non-empty subsets of type <code>T</code>.</p></div></div></div><div class="public anchor" id="var-powerset1-prop"><h3>powerset1-prop</h3><div class="usage"><code>(powerset1-prop [T :type] [x (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (not (s/set-equal x (s/emptyset T))) (set-elem x (powerset1 T)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-powerset1-prop-conv"><h3>powerset1-prop-conv</h3><div class="usage"><code>(powerset1-prop-conv [T :type] [x (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-elem x (powerset1 T)) (not (s/set-equal x (s/emptyset T))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-powerset1-prop-equiv"><h3>powerset1-prop-equiv</h3><div class="usage"><code>(powerset1-prop-equiv [T :type] [x (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (set-elem x (powerset1 T)) (not (s/set-equal x (s/emptyset T))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-set-elem"><h3>set-elem</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(set-elem x X)</code></p>
<p>The set <code>x</code> is an element of the powerset <code>X</code>, cf. <a href="latte-sets.powerset.html#var-set-elem-def">set-elem-def</a>.</p></div></div></div><div class="public anchor" id="var-set-elem-def"><h3>set-elem-def</h3><div class="usage"><code>(set-elem-def [T :type] [x (set T)] [X (powerset T)])</code></div><div class="doc"><div class="markdown"><pre><code>(X x)
</code></pre>
<p><strong>Definition</strong>: Membership for powersets. Th set <code>x</code> is an element of the powerset <code>X</code>.</p></div></div></div><div class="public anchor" id="var-set-ex"><h3>set-ex</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(set-ex X)</code></p>
<p>There exists an element set <code>s</code> of the powerset <code>X</code> such that… cf. <a href="latte-sets.powerset.html#var-set-ex-def">set-ex-def</a>.</p></div></div></div><div class="public anchor" id="var-set-ex-def"><h3>set-ex-def</h3><div class="usage"><code>(set-ex-def [T :type] [X (powerset T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [α :type] (==&gt; (forall [x (set T)] (==&gt; (set-elem x X) α)) α))
</code></pre>
<p><strong>Definition</strong>: The powerset existential. This is the definition of <a href="null">latte.quant/ex</a> but adpated for sets.</p></div></div></div><div class="public anchor" id="var-set-ex-elim"><h3>set-ex-elim</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(set-ex-elim X A)</code></p>
<p>The elimination rule for the set existential, cf. <a href="latte-sets.powerset.html#var-set-ex-elim-thm">set-ex-elim-thm</a>.</p></div></div></div><div class="public anchor" id="var-set-ex-elim-thm"><h3>set-ex-elim-thm</h3><div class="usage"><code>(set-ex-elim-thm [T :type] [X (powerset T)] [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-ex X) (forall [x (set T)] (==&gt; (set-elem x X) A)) A)
</code></pre>
<p><strong>Theorem</strong>: The elimination rule for the set existential.</p></div></div></div><div class="public anchor" id="var-set-ex-intro"><h3>set-ex-intro</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(set-ex-intro X x)</code></p>
<p>Introduction rule for set existential, cf. <a href="latte-sets.powerset.html#var-set-ex-intro-thm">set-ex-intro-thm</a>.</p></div></div></div><div class="public anchor" id="var-set-ex-intro-thm"><h3>set-ex-intro-thm</h3><div class="usage"><code>(set-ex-intro-thm [T :type] [X (powerset T)] [x (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-elem x X) (set-ex X))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for <a href="latte-sets.powerset.html#var-set-ex">set-ex</a>.</p></div></div></div><div class="public anchor" id="var-set-single"><h3>set-single</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(set-single X)</code></p>
<p>There is a single set element in <code>X</code> such that… cf. <a href="latte-sets.powerset.html#var-set-single-def">set-single-def</a></p></div></div></div><div class="public anchor" id="var-set-single-def"><h3>set-single-def</h3><div class="usage"><code>(set-single-def [T :type] [X (powerset T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x y (set T)] (==&gt; (set-elem x X) (set-elem y X) (seteq x y)))
</code></pre>
<p><strong>Definition</strong>: The powerset version of <a href="null">latte.quant/single</a>. There exists at most one set …</p></div></div></div><div class="public anchor" id="var-set-unique"><h3>set-unique</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(set-unique X)</code></p>
<p>There exists a unique set element in <code>X</code> such that… cf. <a href="latte-sets.powerset.html#var-set-unique-def">set-unique-def</a></p></div></div></div><div class="public anchor" id="var-set-unique-def"><h3>set-unique-def</h3><div class="usage"><code>(set-unique-def [T :type] [X (powerset T)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (set-ex X) (set-single X))
</code></pre>
<p><strong>Definition</strong>: The powerset version of <a href="null">latte.quant/unique</a>. There exists a unique set …</p></div></div></div><div class="public anchor" id="var-the-set"><h3>the-set</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(the-set X u)</code></p>
<p>The unique descriptor for powerset <code>X</code>, cf. <a href="latte-sets.powerset.html#var-the-set-ax">the-set-ax</a>.</p></div></div></div><div class="public anchor" id="var-the-set-ax"><h3>the-set-ax</h3><div class="usage"><code>(the-set-ax [T :type] [X (powerset T)] [u (set-unique X)])</code></div><div class="doc"><div class="markdown"><pre><code>(set T)
</code></pre>
<p><strong>Axiom</strong>: The powerset version of <a href="null">latte.quant/the</a>.</p></div></div></div><div class="public anchor" id="var-the-set-lemma"><h3>the-set-lemma</h3><div class="usage"><code>(the-set-lemma [T :type] [X (powerset T)] [u (set-unique X)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [y (set T)] (==&gt; (set-elem y X) (seteq y (the-set X u))))
</code></pre>
<p><strong>Theorem</strong>: The unique set … is unique.</p></div></div></div><div class="public anchor" id="var-the-set-prop"><h3>the-set-prop</h3><div class="usage"><code>(the-set-prop [T :type] [X (powerset T)] [u (set-unique X)])</code></div><div class="doc"><div class="markdown"><pre><code>(set-elem (the-set X u) X)
</code></pre>
<p><strong>Axiom</strong>: The property of the unique set descriptor <a href="latte-sets.powerset.html#var-the-set">the-set</a>.</p></div></div></div><div class="public anchor" id="var-unions"><h3>unions</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(unions X)</code></p>
<p>Generalized union. This is the set {y:T | ∃x∈X, y∈x}.</p></div></div></div><div class="public anchor" id="var-unions-def"><h3>unions-def</h3><div class="usage"><code>(unions-def [T :type] [X (powerset T)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda
 [y T]
 (set-ex (lambda [x (set T)] (and (set-elem x X) (elem y x)))))
</code></pre>
<p><strong>Definition</strong>: Generalized union. This is the set {y:T | ∃x∈X, y∈x}.</p></div></div></div><div class="public anchor" id="var-unions-upper-bound"><h3>unions-upper-bound</h3><div class="usage"><code>(unions-upper-bound [T :type] [X (powerset T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x (set T)] (==&gt; (set-elem x X) (subset x (unions X))))
</code></pre>
<p><strong>Theorem</strong>: The generalized union is an upper bound wrt. the subset relation.</p></div></div></div></div></body></html>