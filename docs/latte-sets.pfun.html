<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-sets.pfun documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-sets</span> <span class="project-version">1.0b10-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte-sets</span></div></div></li><li class="depth-2 branch"><a href="latte-sets.algebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>algebra</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.equiv.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>equiv</span></div></a></li><li class="depth-2 branch current"><a href="latte-sets.pfun.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pfun</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerrel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerrel</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerset</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.quant.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quant</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.ralgebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ralgebra</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.rel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rel</span></div></a></li><li class="depth-2"><a href="latte-sets.set.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-sets.pfun.html#var-bijection"><div class="inner"><span>bijection</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-bijection-injective"><div class="inner"><span>bijection-injective</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-bijection-inverse-bijection"><div class="inner"><span>bijection-inverse-bijection</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-bijection-inverse-bijective"><div class="inner"><span>bijection-inverse-bijective</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-bijection-inverse-functional"><div class="inner"><span>bijection-inverse-functional</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-bijection-inverse-injective"><div class="inner"><span>bijection-inverse-injective</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-bijection-inverse-serial"><div class="inner"><span>bijection-inverse-serial</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-bijection-inverse-surjective"><div class="inner"><span>bijection-inverse-surjective</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-bijection-surjective"><div class="inner"><span>bijection-surjective</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-bijection-unique"><div class="inner"><span>bijection-unique</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-bijective"><div class="inner"><span>bijective</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-bijective-unique"><div class="inner"><span>bijective-unique</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-domain"><div class="inner"><span>domain</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-fetch-functional-type"><div class="inner"><span>fetch-functional-type</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-functional"><div class="inner"><span>functional</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-functional-fun"><div class="inner"><span>functional-fun</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-functional-fun-prop"><div class="inner"><span>functional-fun-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-image"><div class="inner"><span>image</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-injection"><div class="inner"><span>injection</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-injective"><div class="inner"><span>injective</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-injective-contra"><div class="inner"><span>injective-contra</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-injective-single"><div class="inner"><span>injective-single</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-ridentity-functional"><div class="inner"><span>ridentity-functional</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-ridentity-injective"><div class="inner"><span>ridentity-injective</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-serial"><div class="inner"><span>serial</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-serial-alt"><div class="inner"><span>serial-alt</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-serial-alt-serial"><div class="inner"><span>serial-alt-serial</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-serial-serial-alt"><div class="inner"><span>serial-serial-alt</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-smaller"><div class="inner"><span>smaller</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-surjection"><div class="inner"><span>surjection</span></div></a></li><li class="depth-1"><a href="latte-sets.pfun.html#var-surjective"><div class="inner"><span>surjective</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-sets.pfun</h1><div class="doc"><div class="markdown"><p>Partial functions are defined in this namespace as relations (in the type theoretic sense) of type <code>(==&gt; T U :type)</code> together with a domain <code>dom</code> of type <code>(set T)</code> and a codomain <code>cod</code> of type <code>(set U)</code>  such that for any element of the domain there is a unique image in the codomain.</p>
<p><strong>Remark</strong>: in type theory, it is best to rely on total functions because these are ‘native’ through the function type <code>==&gt;</code>. Partial functions are encoded and thus more complex and less ‘natural’, however there are needed for many related (and set-theoretic) concepts (e.g. finite sets).</p></div></div><div class="public anchor" id="var-bijection"><h3>bijection</h3><div class="usage"><code>(bijection [f (rel T U)] [s1 (set T)] [s2 (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(and* (functional f s1 s2) (serial f s1 s2) (bijective f s1 s2))
</code></pre>
<p><strong>Definition</strong>: The relation <code>f</code> is a bijection between sets <code>s1</code> and <code>s2</code>.</p></div></div></div><div class="public anchor" id="var-bijection-injective"><h3>bijection-injective</h3><div class="usage"><code>(bijection-injective [f (rel T U)] [s1 (set T)] [s2 (set U)] [b (bijection f s1 s2)])</code></div><div class="doc"><div class="markdown"><pre><code>(injective f s1 s2)
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-bijection-inverse-bijection"><h3>bijection-inverse-bijection</h3><div class="usage"><code>(bijection-inverse-bijection [f (rel T U)] [s1 (set T)] [s2 (set U)] [b (bijection f s1 s2)])</code></div><div class="doc"><div class="markdown"><pre><code>(bijection (ra/rinverse f) s2 s1)
</code></pre>
<p><strong>Theorem</strong>: The inverse of a bijection is a bijection.</p></div></div></div><div class="public anchor" id="var-bijection-inverse-bijective"><h3>bijection-inverse-bijective</h3><div class="usage"><code>(bijection-inverse-bijective [f (rel T U)] [s1 (set T)] [s2 (set U)] [b (bijection f s1 s2)])</code></div><div class="doc"><div class="markdown"><pre><code>(bijective (ra/rinverse f) s2 s1)
</code></pre>
<p><strong>Theorem</strong>: The inverse of bijective relation <code>f</code> is bijective.</p></div></div></div><div class="public anchor" id="var-bijection-inverse-functional"><h3>bijection-inverse-functional</h3><div class="usage"><code>(bijection-inverse-functional [f (rel T U)] [s1 (set T)] [s2 (set U)] [b (bijection f s1 s2)])</code></div><div class="doc"><div class="markdown"><pre><code>(functional (ra/rinverse f) s2 s1)
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-bijection-inverse-injective"><h3>bijection-inverse-injective</h3><div class="usage"><code>(bijection-inverse-injective [f (rel T U)] [s1 (set T)] [s2 (set U)] [b (bijection f s1 s2)])</code></div><div class="doc"><div class="markdown"><pre><code>(injective (ra/rinverse f) s2 s1)
</code></pre>
<p><strong>Theorem</strong>: The inverse of bijective relation <code>f</code> is injective.</p></div></div></div><div class="public anchor" id="var-bijection-inverse-serial"><h3>bijection-inverse-serial</h3><div class="usage"><code>(bijection-inverse-serial [f (rel T U)] [s1 (set T)] [s2 (set U)] [b (bijection f s1 s2)])</code></div><div class="doc"><div class="markdown"><pre><code>(serial (ra/rinverse f) s2 s1)
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-bijection-inverse-surjective"><h3>bijection-inverse-surjective</h3><div class="usage"><code>(bijection-inverse-surjective [f (rel T U)] [s1 (set T)] [s2 (set U)] [b (bijection f s1 s2)])</code></div><div class="doc"><div class="markdown"><pre><code>(surjective (ra/rinverse f) s2 s1)
</code></pre>
<p><strong>Theorem</strong>: The inverse of bijective relation <code>f</code> is surjective.</p></div></div></div><div class="public anchor" id="var-bijection-surjective"><h3>bijection-surjective</h3><div class="usage"><code>(bijection-surjective [f (rel T U)] [s1 (set T)] [s2 (set U)] [b (bijection f s1 s2)])</code></div><div class="doc"><div class="markdown"><pre><code>(surjective f s1 s2)
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-bijection-unique"><h3>bijection-unique</h3><div class="usage"><code>(bijection-unique [f (rel T U)] [s1 (set T)] [s2 (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (bijection f s1 s2)
 (forall-in
  [z s2]
  (sq/unique-in
   s1
   (lambda [x T] (forall-in [w s2] (==&gt; (f x w) (equal w z)))))))
</code></pre>
<p><strong>Theorem</strong>: The relation <code>f</code> is a bijection between sets <code>s1</code> and <code>s2</code>, hence it is <em>unique</em>.</p></div></div></div><div class="public anchor" id="var-bijective"><h3>bijective</h3><div class="usage"><code>(bijective [f (rel T U)] [s1 (set T)] [s2 (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (injective f s1 s2) (surjective f s1 s2))
</code></pre>
<p><strong>Definition</strong>: The relation <code>f</code> is both <a href="latte-sets.pfun.html#var-injective">injective</a> and <a href="latte-sets.pfun.html#var-bijective">bijective</a> wrt. sets <code>s1</code> and <code>s2</code>. A <a href="latte-sets.pfun.html#var-bijection">bijection</a> needs to be also <a href="latte-sets.pfun.html#var-functional">functional</a> and <a href="latte-sets.pfun.html#var-serial">serial</a>.</p></div></div></div><div class="public anchor" id="var-bijective-unique"><h3>bijective-unique</h3><div class="usage"><code>(bijective-unique [f (rel T U)] [s1 (set T)] [s2 (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (functional f s1 s2)
 (serial f s1 s2)
 (bijective f s1 s2)
 (forall-in
  [z s2]
  (sq/unique-in
   s1
   (lambda [x T] (forall-in [w s2] (==&gt; (f x w) (equal w z)))))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-domain"><h3>domain</h3><div class="usage"><code>(domain [f (rel T U)] [from (set T)] [to (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(set-of [x T] (and (elem x from) (sq/exists-in [y to] (f x y))))
</code></pre>
<p><strong>Definition</strong>: The actual domain of relation <code>f</code>, taking antecedents in <code>from</code>. It is sometimes called the active domain of <code>f</code>.</p></div></div></div><div class="public anchor" id="var-fetch-functional-type"><h3>fetch-functional-type</h3><div class="usage"><code>(fetch-functional-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-functional"><h3>functional</h3><div class="usage"><code>(functional [f (rel T U)] [from (set T)] [to (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall-in
 [x from]
 (forall-in
  [y1 to]
  (forall-in [y2 to] (==&gt; (f x y1) (f x y2) (equal y1 y2)))))
</code></pre>
<p><strong>Definition</strong>: The relation <code>f</code> is functional (a.k.a. right-unique) on the domain-set <code>from</code>.  and range set <code>to</code>.</p></div></div></div><div class="public anchor" id="var-functional-fun"><h3>functional-fun</h3><div class="usage"><code>(functional-fun [f (==&gt; T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [y U] (equal (f x) y)))
</code></pre>
<p><strong>Definition</strong>: The “partial” function of a (total) type-theoretic function <code>f</code> on its whole domain</p></div></div></div><div class="public anchor" id="var-functional-fun-prop"><h3>functional-fun-prop</h3><div class="usage"><code>(functional-fun-prop [f (==&gt; T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall
 [from (set T)]
 (forall [to (set U)] (functional (functional-fun f) from to)))
</code></pre>
<p><strong>Theorem</strong>: A type-theoretic function <code>f</code> is a partial function for any domain restriction.</p></div></div></div><div class="public anchor" id="var-image"><h3>image</h3><div class="usage"><code>(image [f (rel T U)] [from (set T)] [to (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(set-of [y U] (and (elem y to) (exists-in [x from] (f x y))))
</code></pre>
<p><strong>Definition</strong>: The image of set <code>from</code> through relation <code>f</code>. This is also sometimes called the <em>range</em> or <em>codomain</em> but image is less ambiguous (especially in type theory).</p></div></div></div><div class="public anchor" id="var-injection"><h3>injection</h3><div class="usage"><code>(injection [f (rel T U)] [s1 (set T)] [s2 (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(and* (functional f s1 s2) (serial f s1 s2) (injective f s1 s2))
</code></pre>
<p><strong>Definition</strong>: </p></div></div></div><div class="public anchor" id="var-injective"><h3>injective</h3><div class="usage"><code>(injective [f (rel T U)] [from (set T)] [to (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall-in
 [x1 from]
 (forall-in
  [x2 from]
  (forall-in
   [y1 to]
   (forall-in
    [y2 to]
    (==&gt; (f x1 y1) (f x2 y2) (equal y1 y2) (equal x1 x2))))))
</code></pre>
<p><strong>Definition</strong>: The relation <code>f</code> is injective wrt. domain set <code>from</code> and range set <code>to</code>. </p>
<p>Note that this notion of injectivity is about comparing sets, not types. Here, the actual meaning is that <code>s1</code> is less than <code>s2</code>.</p>
<p>Also, the relation is not constrained to be e.g. <a href="latte-sets.pfun.html#var-functional">functional</a>  or <a href="latte-sets.pfun.html#var-serial">serial</a> (and in practice these are frequent although  not always required assumptions.).</p></div></div></div><div class="public anchor" id="var-injective-contra"><h3>injective-contra</h3><div class="usage"><code>(injective-contra [f (rel T U)] [from (set T)] [to (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (injective f from to)
 (forall-in
  [x1 from]
  (forall-in
   [x2 from]
   (forall-in
    [y1 to]
    (forall-in
     [y2 to]
     (==&gt;
      (f x1 y1)
      (f x2 y2)
      (not (equal x1 x2))
      (not (equal y1 y2))))))))
</code></pre>
<p><strong>Theorem</strong>: The contrapositive of <a href="latte-sets.pfun.html#var-injective">injective</a>, useful for proofs by contradiction.</p></div></div></div><div class="public anchor" id="var-injective-single"><h3>injective-single</h3><div class="usage"><code>(injective-single [f (rel T U)] [s1 (set T)] [s2 (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (serial f s1 s2)
 (injective f s1 s2)
 (forall-in
  [z s2]
  (sq/single-in
   s1
   (lambda [x T] (forall-in [w s2] (==&gt; (f x w) (equal w z)))))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-ridentity-functional"><h3>ridentity-functional</h3><div class="usage"><code>(ridentity-functional [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall
 [from (set T)]
 (forall [to (set T)] (functional (rel/identity T) from to)))
</code></pre>
<p><strong>Theorem</strong>: The identity relation is a partial function on any domain set.</p></div></div></div><div class="public anchor" id="var-ridentity-injective"><h3>ridentity-injective</h3><div class="usage"><code>(ridentity-injective [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [s (set T)] (injective (rel/identity T) s s))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-serial"><h3>serial</h3><div class="usage"><code>(serial [f (rel T U)] [from (set T)] [to (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall-in [x from] (exists-in [y to] (f x y)))
</code></pre>
<p><strong>Definition</strong>: The relation <code>f</code> covers all of (is total wrt.) the provided <code>from</code> domain set.</p></div></div></div><div class="public anchor" id="var-serial-alt"><h3>serial-alt</h3><div class="usage"><code>(serial-alt [f (rel T U)] [from (set T)] [to (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(seteq (domain f from to) from)
</code></pre>
<p><strong>Definition</strong>: Alternative definition for <a href="latte-sets.pfun.html#var-serial">serial</a>.</p></div></div></div><div class="public anchor" id="var-serial-alt-serial"><h3>serial-alt-serial</h3><div class="usage"><code>(serial-alt-serial [f (rel T U)] [from (set T)] [to (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (serial-alt f from to) (serial f from to))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-serial-serial-alt"><h3>serial-serial-alt</h3><div class="usage"><code>(serial-serial-alt [f (rel T U)] [from (set T)] [to (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (serial f from to) (serial-alt f from to))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-smaller"><h3>smaller</h3><div class="usage"><code>(smaller [s1 (set T)] [s2 (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(rel-ex (lambda [f (rel T U)] (injection f s1 s2)))
</code></pre>
<p><strong>Definition</strong>: The set <code>s1</code> is “smaller” than <code>s2</code>.</p></div></div></div><div class="public anchor" id="var-surjection"><h3>surjection</h3><div class="usage"><code>(surjection [f (rel T U)] [s1 (set T)] [s2 (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(and* (functional f s1 s2) (serial f s1 s2) (surjective f s1 s2))
</code></pre>
<p><strong>Definition</strong>: The relation <code>f</code> is a functional surjection on-to set <code>s2</code>.</p></div></div></div><div class="public anchor" id="var-surjective"><h3>surjective</h3><div class="usage"><code>(surjective [f (rel T U)] [s1 (set T)] [s2 (set U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall-in [y s2] (exists-in [x s1] (f x y)))
</code></pre>
<p><strong>Definition</strong>: The relation <code>f</code> is surjective onto <code>s2</code> for domain <code>s1</code>.</p></div></div></div></div></body></html>