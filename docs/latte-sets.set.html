<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-sets.set documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-sets</span> <span class="project-version">1.0b10-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte-sets</span></div></div></li><li class="depth-2 branch"><a href="latte-sets.algebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>algebra</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.equiv.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>equiv</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.pfun.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pfun</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerrel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerrel</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerset</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.quant.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quant</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.ralgebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ralgebra</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.rel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rel</span></div></a></li><li class="depth-2 current"><a href="latte-sets.set.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-sets.set.html#var-elem"><div class="inner"><span>elem</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-elem-def"><div class="inner"><span>elem-def</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-element-type-of"><div class="inner"><span>element-type-of</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-emptyset"><div class="inner"><span>emptyset</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-emptyset-prop"><div class="inner"><span>emptyset-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-fetch-set-type"><div class="inner"><span>fetch-set-type</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-fullset"><div class="inner"><span>fullset</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-fullset-intro"><div class="inner"><span>fullset-intro</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-psubset"><div class="inner"><span>psubset</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-psubset-antirefl"><div class="inner"><span>psubset-antirefl</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-psubset-antisym"><div class="inner"><span>psubset-antisym</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-psubset-emptyset"><div class="inner"><span>psubset-emptyset</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-psubset-emptyset-conv"><div class="inner"><span>psubset-emptyset-conv</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-psubset-emptyset-equiv"><div class="inner"><span>psubset-emptyset-equiv</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-psubset-trans"><div class="inner"><span>psubset-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-set"><div class="inner"><span>set</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-set-equal"><div class="inner"><span>set-equal</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-set-equal-implies-seteq"><div class="inner"><span>set-equal-implies-seteq</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-set-equal-implies-subset"><div class="inner"><span>set-equal-implies-subset</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-set-equal-prop"><div class="inner"><span>set-equal-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-set-equal-refl"><div class="inner"><span>set-equal-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-set-equal-seteq"><div class="inner"><span>set-equal-seteq</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-set-equal-sym"><div class="inner"><span>set-equal-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-set-equal-trans"><div class="inner"><span>set-equal-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-set-of"><div class="inner"><span>set-of</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-seteq"><div class="inner"><span>seteq</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-seteq-implies-set-equal"><div class="inner"><span>seteq-implies-set-equal</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-seteq-refl"><div class="inner"><span>seteq-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-seteq-sym"><div class="inner"><span>seteq-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-seteq-trans"><div class="inner"><span>seteq-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-subset"><div class="inner"><span>subset</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-subset-elim"><div class="inner"><span>subset-elim</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-subset-emptyset-lower-bound"><div class="inner"><span>subset-emptyset-lower-bound</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-subset-fullset-upper-bound"><div class="inner"><span>subset-fullset-upper-bound</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-subset-intro"><div class="inner"><span>subset-intro</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-subset-prop"><div class="inner"><span>subset-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-subset-refl"><div class="inner"><span>subset-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.set.html#var-subset-trans"><div class="inner"><span>subset-trans</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-sets.set</h1><div class="doc"><div class="markdown"><p>Set-theoretic notions based on the subset  approach of type theory.</p>
<p>The main idea is to consider a typed variant of  a mathematical set as a predicate over a given type.</p>
<p>What is called a <strong>set</strong> will be technically-speaking  a subset of a type, hence a predicate over a given type.  This means that the set theory developed here is <em>typed</em>  and thus quite different than the standard axiomatic set theories (e.g. ZF and ZFC), which are essentially untyped.</p>
<p>But many set-theoretic constructions and results have a natural translation to the typed setting.</p></div></div><div class="public anchor" id="var-elem"><h3>elem</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>(elem x s)</code> means <code>x</code> is an element of set <code>s</code>, cf. <a href="latte-sets.set.html#var-elem-def">elem-def</a>.</p></div></div></div><div class="public anchor" id="var-elem-def"><h3>elem-def</h3><div class="usage"><code>(elem-def [T :type] [x T] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(s x)
</code></pre>
<p><strong>Definition</strong>: Set membership. </p>
<p><code>(elem x s)</code> means that <code>x</code> (of implicit type <code>T</code>) is an element of set <code>s</code>.  The standard mathematical notation is: <code>x</code>∊<code>s</code>.</p></div></div></div><div class="public anchor" id="var-element-type-of"><h3>element-type-of</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Replaces <code>sterm</code> by its element type (if it is a set type).</p></div></div></div><div class="public anchor" id="var-emptyset"><h3>emptyset</h3><div class="usage"><code>(emptyset [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(set-of [x T] p/absurd)
</code></pre>
<p><strong>Definition</strong>: The empty set of a type.</p></div></div></div><div class="public anchor" id="var-emptyset-prop"><h3>emptyset-prop</h3><div class="usage"><code>(emptyset-prop [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (not (elem x (emptyset T))))
</code></pre>
<p><strong>Theorem</strong>: The main property of the empty set.</p></div></div></div><div class="public anchor" id="var-fetch-set-type"><h3>fetch-set-type</h3><div class="usage"><code>(fetch-set-type def-env ctx s-type)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-fullset"><h3>fullset</h3><div class="usage"><code>(fullset [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(set-of [x T] p/truth)
</code></pre>
<p><strong>Definition</strong>: The full set of a type (all the inhabitants of the type are element of the full set).</p></div></div></div><div class="public anchor" id="var-fullset-intro"><h3>fullset-intro</h3><div class="usage"><code>(fullset-intro [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (elem x (fullset T)))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for the full set.</p></div></div></div><div class="public anchor" id="var-psubset"><h3>psubset</h3><div class="usage"><code>(psubset [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (subset s1 s2) (not (seteq s1 s2)))
</code></pre>
<p><strong>Definition</strong>: The anti-reflexive variant of the subset relation.</p>
<p>The expression <code>(psubset T s1 s2)</code> means that  the set <code>s1</code> is a subset of <code>s2</code>, but that the two sets are distinct, i.e. <code>s1</code>⊂<code>s2</code> (or more explicitely <code>s1</code>⊊<code>s2</code>).</p></div></div></div><div class="public anchor" id="var-psubset-antirefl"><h3>psubset-antirefl</h3><div class="usage"><code>(psubset-antirefl [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(not (psubset s s))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubset-antisym"><h3>psubset-antisym</h3><div class="usage"><code>(psubset-antisym [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(not (and (psubset s1 s2) (psubset s2 s1)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubset-emptyset"><h3>psubset-emptyset</h3><div class="usage"><code>(psubset-emptyset [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (psubset (emptyset T) s) (not (seteq s (emptyset T))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubset-emptyset-conv"><h3>psubset-emptyset-conv</h3><div class="usage"><code>(psubset-emptyset-conv [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (not (seteq s (emptyset T))) (psubset (emptyset T) s))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubset-emptyset-equiv"><h3>psubset-emptyset-equiv</h3><div class="usage"><code>(psubset-emptyset-equiv [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (psubset (emptyset T) s) (not (seteq s (emptyset T))))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-psubset-trans"><h3>psubset-trans</h3><div class="usage"><code>(psubset-trans [s1 (set T)] [s2 (set T)] [s3 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (psubset s1 s2) (psubset s2 s3) (psubset s1 s3))
</code></pre>
<p><strong>Theorem</strong>: The proper subset relation is transitive.</p></div></div></div><div class="public anchor" id="var-set"><h3>set</h3><div class="usage"><code>(set [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; T :type)
</code></pre>
<p><strong>Definition</strong>: The type of sets whose elements are of type <code>T</code>.</p></div></div></div><div class="public anchor" id="var-set-equal"><h3>set-equal</h3><div class="usage"><code>(set-equal [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [P (==&gt; (set T) :type)] (&lt;=&gt; (P s1) (P s2)))
</code></pre>
<p><strong>Definition</strong>: A <em>Leibniz</em>-style equality for sets.</p>
<p>It says that two sets <code>s1</code> and <code>s2</code> are equal iff for any predicate <code>P</code> then <code>(P s1)</code> if and only if <code>(P s2)</code>.</p>
<p>Note that the identification with <a href="latte-sets.set.html#var-seteq">seteq</a> is non-trivial,  and requires an axiom.</p></div></div></div><div class="public anchor" id="var-set-equal-implies-seteq"><h3>set-equal-implies-seteq</h3><div class="usage"><code>(set-equal-implies-seteq [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal s1 s2) (seteq s1 s2))
</code></pre>
<p><strong>Theorem</strong>: Subset-based equality implies <em>Leibniz</em>-style equality on sets.</p></div></div></div><div class="public anchor" id="var-set-equal-implies-subset"><h3>set-equal-implies-subset</h3><div class="usage"><code>(set-equal-implies-subset [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal s1 s2) (subset s1 s2))
</code></pre>
<p><strong>Theorem</strong>: Going from <em>Leibniz</em> equality on sets to the subset relation is easy.</p></div></div></div><div class="public anchor" id="var-set-equal-prop"><h3>set-equal-prop</h3><div class="usage"><code>(set-equal-prop [s1 (set T)] [s2 (set T)] [P (==&gt; (set T) :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal s1 s2) (P s1) (P s2))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-set-equal-refl"><h3>set-equal-refl</h3><div class="usage"><code>(set-equal-refl [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(set-equal s s)
</code></pre>
<p><strong>Theorem</strong>: Reflexivity of set equality.</p></div></div></div><div class="public anchor" id="var-set-equal-seteq"><h3>set-equal-seteq</h3><div class="usage"><code>(set-equal-seteq [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (seteq s1 s2) (set-equal s1 s2))
</code></pre>
<p><strong>Theorem</strong>: Set equality and subset-based equality (should) coincide (axiomatically).</p></div></div></div><div class="public anchor" id="var-set-equal-sym"><h3>set-equal-sym</h3><div class="usage"><code>(set-equal-sym [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal s1 s2) (set-equal s2 s1))
</code></pre>
<p><strong>Theorem</strong>: Symmetry of set equality.</p></div></div></div><div class="public anchor" id="var-set-equal-trans"><h3>set-equal-trans</h3><div class="usage"><code>(set-equal-trans [s1 (set T)] [s2 (set T)] [s3 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal s1 s2) (set-equal s2 s3) (set-equal s1 s3))
</code></pre>
<p><strong>Theorem</strong>: Transitivity of set equality.</p></div></div></div><div class="public anchor" id="var-set-of"><h3>set-of</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Definition of a set by comprehension.</p>
<p><code>(set-of [x T] (P x))</code> is the set of all <code>x</code>’s of type <code>T</code> such  that <code>(P x)</code>. This is similar to the notation <code>{x : T | P(x) }</code> in classical mathematics.</p>
<p>Note that it is exactly the same as <code>(lambda [x T] (P x))</code></p></div></div></div><div class="public anchor" id="var-seteq"><h3>seteq</h3><div class="usage"><code>(seteq [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (subset s1 s2) (subset s2 s1))
</code></pre>
<p><strong>Definition</strong>: Set equivalence. Set <code>s1</code> is equal to <code>s2</code> This is a natural notion of “equal sets”  based on the subset relation.</p></div></div></div><div class="public anchor" id="var-seteq-implies-set-equal"><h3>seteq-implies-set-equal</h3><div class="usage"><code>(seteq-implies-set-equal [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (seteq s1 s2) (set-equal s1 s2))
</code></pre>
<p><strong>Axiom</strong>: Going from subset-based equality to <em>Leibniz</em>-style equality requires this axiom. This is because we cannot lift membership  to an arbitrary predicate.</p></div></div></div><div class="public anchor" id="var-seteq-refl"><h3>seteq-refl</h3><div class="usage"><code>(seteq-refl [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(seteq s s)
</code></pre>
<p><strong>Theorem</strong>: Set equality is reflexive.</p></div></div></div><div class="public anchor" id="var-seteq-sym"><h3>seteq-sym</h3><div class="usage"><code>(seteq-sym [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (seteq s1 s2) (seteq s2 s1))
</code></pre>
<p><strong>Theorem</strong>: Set equality is symmetric.</p></div></div></div><div class="public anchor" id="var-seteq-trans"><h3>seteq-trans</h3><div class="usage"><code>(seteq-trans [s1 (set T)] [s2 (set T)] [s3 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (seteq s1 s2) (seteq s2 s3) (seteq s1 s3))
</code></pre>
<p><strong>Theorem</strong>: Set equality is transitive.</p></div></div></div><div class="public anchor" id="var-subset"><h3>subset</h3><div class="usage"><code>(subset [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (==&gt; (elem x s1) (elem x s2)))
</code></pre>
<p><strong>Definition</strong>: The subset relation for type <code>T</code>. The expression <code>(subset-def T s1 s2)</code> means that  the set <code>s1</code> is a subset of <code>s2</code>, i.e. <code>s1</code>⊆<code>s2</code>.</p></div></div></div><div class="public anchor" id="var-subset-elim"><h3>subset-elim</h3><div class="usage"><code>(subset-elim [s1 (set T)] [s2 (set T)] [x T])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (elem x s1) (subset s1 s2) (elem x s2))
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for subset relation.</p></div></div></div><div class="public anchor" id="var-subset-emptyset-lower-bound"><h3>subset-emptyset-lower-bound</h3><div class="usage"><code>(subset-emptyset-lower-bound [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(subset (emptyset T) s)
</code></pre>
<p><strong>Theorem</strong>: The emptyset is a subset of every other sets.</p></div></div></div><div class="public anchor" id="var-subset-fullset-upper-bound"><h3>subset-fullset-upper-bound</h3><div class="usage"><code>(subset-fullset-upper-bound [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(subset s (fullset T))
</code></pre>
<p><strong>Theorem</strong>: The fullset is a superset of every other sets.</p></div></div></div><div class="public anchor" id="var-subset-intro"><h3>subset-intro</h3><div class="usage"><code>(subset-intro [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (forall [x T] (==&gt; (elem x s1) (elem x s2))) (subset s1 s2))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for subset relation.</p></div></div></div><div class="public anchor" id="var-subset-prop"><h3>subset-prop</h3><div class="usage"><code>(subset-prop [P (==&gt; T :type)] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (forall [x T] (==&gt; (elem x s2) (P x)))
 (subset s1 s2)
 (forall [x T] (==&gt; (elem x s1) (P x))))
</code></pre>
<p><strong>Theorem</strong>: Preservation of properties on subsets.</p></div></div></div><div class="public anchor" id="var-subset-refl"><h3>subset-refl</h3><div class="usage"><code>(subset-refl [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(subset s s)
</code></pre>
<p><strong>Theorem</strong>: The subset relation is reflexive.</p></div></div></div><div class="public anchor" id="var-subset-trans"><h3>subset-trans</h3><div class="usage"><code>(subset-trans [s1 (set T)] [s2 (set T)] [s3 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (subset s1 s2) (subset s2 s3) (subset s1 s3))
</code></pre>
<p><strong>Theorem</strong>: The subset relation is transitive.</p></div></div></div></div></body></html>